----------------------------------------
-- File: 'attackstrategy.ai'
-- Edited by Thudmeizer @ 05.03.2005
-- Edited by LarkinVB   @ 19.08.2005
-- Edited by Flenser    @ 30.05.2005
-- Edited by Arkhan	@ 06.01.2006

class 'AttackStrategy' (Strategy)

-- Settings
AttackStrategy.iMaxArmySize 		= 4000		-- Too much army at one point is not good
AttackStrategy.fBestAttackRatio		= 3 / 2		-- Set best attack ratio of allied to enemy forces
AttackStrategy.fWorstAttackRatio	= 1 / 2		-- Set worst attack ratio of allied to enemy forces
AttackStrategy.fRequiredAttackRatio	= 5 / 4
AttackStrategy.iLocalRange			= 35
AttackStrategy.iNearRange			= 70
AttackStrategy.iMidRange			= 120
AttackStrategy.iLongRange			= 180
AttackStrategy.iUnitAveragePower	= 250
AttackStrategy.iAttackDelayTime 	= 20		-- Minimum time an attack has to be computed (In seconds)
AttackStrategy.iCriticalAttackTime 	= 180		-- If countdown started, the AI will wait this time until it tries to stop it (In seconds)
AttackStrategy.fAttackDeviation 	= 1 / 5		-- Used for checking if an attack target is blocked by a base, post or army
AttackStrategy.bCounterVO			= false


function AttackStrategy:__init( info ) super( info )

	-- Init member variables
	self.m_oEnemy = nil
	self.m_vAttackPosition = Vector3f(0, 0, 0)	
    self.m_oAttackPlan = nil
    self.m_bHelpFriend = false
    self.m_iMyself = 0
    self.m_iNextUpdate = 0
    
    -- PlayerInfo arrays
	self.m_aAllies	= {}
	self.m_aEnemies	= {}
end

function AttackStrategy:GetName()
	return "AttackStrategy"
end

function AttackStrategy:Update()

	-- Superclass
	Strategy.Update(self)

	-- Check last update
	if (g_iGMT < self.m_iNextUpdate or g_iGMT < CpuManager.AISettings.iAttackDelay * 60) then
		return
	end
	self.m_iNextUpdate = g_iGMT + 10
	
	aitrace("AttackStrategy: Update...", true)
	
	-- Update countdown for critical points
	self:UpdateStrategicObjective()
		
	-- If no attack plan exists, try to add a new one
	if (self.m_oAttackPlan == nil) then
	
		-- Check attack delay time
		if (not DefendStrategy.bDefending or cpu_manager:GetArmyStrength() > 4000) then
			self:ChooseTarget()
		end
	elseif (self.m_oAttackPlan:IsComplete()) then
		self:ResetAttack()
	end
	
	-- Make sure that we have an attack plan
	if (self.m_oAttackPlan ~= nil and not AttackStrategy.bCounterVO) then
	
	    -- Retreat, if there's a big threat at my HQ
	    local iMinThreat = cpu_manager:GetTierLevel() * 400
	    if (cpu_manager:GetCriticalThreat() > iMinThreat and cpu_manager:GetCriticalSituation() > 0) then
		   
			-- Move all my dudes to home base position
			aitrace("AttackStrategy: Retreat!!! HQ under threat.")
			self:Retreat(vBasePos)
	    end
	end
	
	-- Make sure that we have an attack plan
	if (self.m_oAttackPlan ~= nil and not AttackStrategy.bCounterVO) then
	
		-- Check if we should abort the attack to save an ally
		self:HelpAllyInNeed()
	end
    
	-- Make sure that we have an attack plan
	if (self.m_oAttackPlan ~= nil and not AttackStrategy.bCounterVO) then
	
	    -- Check if we should abort the attack and retreat
	    if (not self:CheckAttackSituation()) then
	    		    
	   		-- Move all my dudes to closest base
	   		aitrace("AttackStrategy: Retreat!!! Situation is too dangerous.")
			self:Retreat(nil)
		end
	end
	
	-- Make sure that we have an attack plan
	if (self.m_oAttackPlan ~= nil and not AttackStrategy.bCounterVO) then
	
		-- Check if the attack was successfull
		if (self:CheckSuccess()) then
		
			-- I'm done. (FIXME: should be success)
			aitrace("AttackStrategy: Mission accomplished!!!")
			self:ResetAttack()
			self:PostEvent(Strategy.Events.OnFailure)
		end
	end
end

function AttackStrategy:UpdateStrategicObjective()
	
	aitrace("AttackStrategy: Update strategic objective...")
	
	-- Check if countdown is active
	if (cpu_manager.m_iCriticalTimer < 0) then

		-- Abort attack on critical if necessary
		if (AttackStrategy.bCounterVO) then
			aitrace("Countdown stopped. Abort attack on critical!")
			self:ResetAttack()
		end
		return
	end
	
	-- Check if it is time to stop the timer
	if (g_iGMT < cpu_manager.m_iCriticalTimer + AttackStrategy.iCriticalAttackTime or not cpu_manager.m_bTakeAndHoldMode) then
		return
	end
	
	-- Get all critical points, owned by enemies
	local vEnemyCriticalPositions = {}
	local oCriticalOwner = {}
	for oStrategicPoint in resource_manager:GetStrategicPointAIs() do
	
		-- Check if strategic point is a critical
		if (oStrategicPoint:IsStrategicObjective()) then
		
			-- Check if critical point has an owner
			local iIDOwner = oStrategicPoint:Owner()
			if (iIDOwner > 0) then
								
				-- Get owner of the critical point
				for oPlayer in cpu_manager.stats:GetPlayerStats() do

					-- Check if player is the owner of the critical point
					if (iIDOwner == oPlayer:GetPlayerID()) then
					
						-- Check if the owner is an enemy
						if (cpu_manager.player_stats:IsEnemy(oPlayer)) then
							table.insert(vEnemyCriticalPositions, oStrategicPoint:GetEntity():GetPosition())
							table.insert(oCriticalOwner, oPlayer)
						end
					end
				end
			end
		end
	end
	
	-- Leave if there's already an attack on a critical point
	if (AttackStrategy.bCounterVO) then
	
		-- Check if we already conquered the critical but there's still another one
		for iLoop1 in vEnemyCriticalPositions do
			if (distance_sqr(self.m_vAttackPosition, vEnemyCriticalPositions[iLoop1]) < 1) then
				return
			end
		end
		aitrace("Target critical captured! Others remain...")
	end
					
	-- Init attack on critical point closest to my base
	local iDistanceToCritical = 0
	local vAttackPos = Vector3f()
	local oEnemy = nil
	for iLoop1 in vEnemyCriticalPositions do
	
		-- Check distance from start pos to critical point
		local iDistance = distance_sqr(cpu_manager.start_pos, vEnemyCriticalPositions[iLoop1])
		
		-- If distance is lesser than previous critical, then take this one
		if (iDistanceToCritical == 0 or iDistance < iDistanceToCritical) then
			vAttackPos = vEnemyCriticalPositions[iLoop1]
			oEnemy = oCriticalOwner[iLoop1]
			iDistanceToCritical = iDistance
		end
	end
	
	-- Leave if no point was found (Should never happen)
	if (oEnemy == nil) then
		return
	end
	
	-- Reset attack
	self:ResetAttack()
	
	-- Init new attack
	self.m_vAttackPosition = vAttackPos
	self.m_oEnemy = oEnemy
	AttackStrategy.bCounterVO = true
	
	-- Make sure that all troops from other plans are unlocked (We need them!)
	cpu_manager:ForceReleaseDefenders()

	-- Set minimum amount of units
	local iMinArmyPower = self.info.MinArmyStrength

	-- Add attack plan
	aitrace("Init attack on critical point!!!")
	self.m_oAttackPlan = AttackPlan(self.m_oEnemy, self.m_vAttackPosition, cpu_manager.start_pos, iMinArmyPower, self.info.max_army_percentage)
	self:AddPlan(self.m_oAttackPlan)
end

function AttackStrategy:ResetAttack()

	aitrace("AttackStrategy: Reset attack...")

	-- Set attack plan as complete
	if (self.m_oAttackPlan ~= nil) then
		self.m_oAttackPlan:SetComplete(true)
	end
	
	-- Reset attack stats
	self.m_oEnemy = nil
	self.m_vAttackPosition = Vector3f(0, 0, 0)
    self.m_oAttackPlan = nil
    self.m_bHelpFriend = false
    AttackStrategy.bCounterVO = false
    
    -- Release all
    self:ForceReleaseAll()
end

-- Check if we should abort the attack and retreat
function AttackStrategy:CheckAttackSituation()

	aitrace("AttackStrategy: Check attack situation...")

	-- Wait until enough troops were obtained
	if (g_iGMT < self.m_iNextUpdate) then
		return true
	end

    -- Check my army strength
    local iMyArmyStrength, vArmyPos, bBaseBuster = self.m_oAttackPlan:GetArmyStrength()
    local iMinArmyPower = cpu_manager:GetTierLevel() * (cpu_manager:MinArmyStrengthPerTier() * 3 / 4)
    if (iMyArmyStrength < iMinArmyPower) then
    	return false
    elseif (iMyArmyStrength < 1000 and not bBaseBuster) then
    	return false
    elseif (iMyArmyStrength > 2000) then
    	return true
    end
    
	-- Compare army strengths
    local iEnemyArmyStrength = cpu_manager:GetArmyStrength(self.m_oEnemy)
    local fRatio = cpu_manager:GetRetreatRatio()
    if (iMyArmyStrength < fRatio * iEnemyArmyStrength) then
    	return false
    end
    
	-- Check threat at attack position
	local iEnemyPower, iAlliedPower, iMyPower = cpu_manager:GetArmyStrengthAtPos(self.m_vAttackPosition, 50)
	local iEnemyThreat = iEnemyPower - iAlliedPower + iMyPower
	if (iMyArmyStrength < fRatio * iEnemyThreat) then
		return false
	end
	
	-- Create array of attacking units
	local aUnits = {}
	for iLoop1 in self.m_oAttackPlan.attack_units do
	
		-- Get unit
		local oUnit = self.m_oAttackPlan.attack_units[iLoop1]
		
		-- Check if unit is valid
		if (oUnit:IsValid() and (oUnit:WasRecentlyHurt() or oUnit:IsInCombat())) then
		
			-- Store unit data
			table.insert(aUnits, { oUnit:GetPosition(), 3 * oUnit:GetTactic():GetUnitStrength() })
		end
	end
	
	-- Check if we've units in contact with the enemy
	local iTotalDefendStrength = 0
	if (table.getn(aUnits) > 0) then
	
		-- Check, which enemy units and buildings are in contact with our units
		local iRange = sqr(35)
		for oPlayer in cpu_manager.stats:GetPlayerStats() do
		
			-- Check only enemies
			if (cpu_manager.player_stats:IsEnemy(oPlayer) and not oPlayer:IsPlayerDead()) then
		
				-- Compute all player squads
				for oSquad in oPlayer:GetSquads() do
					
					-- Check if unit is valid
					if (oSquad:IsValid() and not oSquad:IsEngineer()) then
					
						-- Get squad position
						local vSquadPosition = oSquad:GetPosition()
						
						-- Get squad power
						local iSquadPower = cpu_manager:GetUnitStrength(oSquad)
						
						-- Add the strenth of enemy units to total defend strength if they are close to one of our attack units
						local iSquadCount = table.getn( aUnits )
						for iLoop1 = iSquadCount, 1, -1 do
						
							-- Check distance
							if (distance_sqr(aUnits[iLoop1][1], vSquadPosition) < iRange) then
								
								-- Add unit strength to total defend strength
								iTotalDefendStrength = iTotalDefendStrength + iSquadPower
								
								-- Substract unit strength from squad defend strength capacity
								aUnits[iLoop1][2] = aUnits[iLoop1][2] - iSquadPower
								
								-- Check if squad defend strength exceeds limit
								if (aUnits[iLoop1][2] < 0) then
									table.remove(aUnits, iLoop1)
								end
								break
							end
						end
					end
				end
				
				-- Compute all player turrets
				local sRace = oPlayer:GetPlayerRaceName()
				local iPostThreat = cpu_manager:GetTurretPower(sRace)
				for oBuilding in oPlayer:GetBases() do
		  
		  			-- Check for valid building
					if (oBuilding:IsValid() and oBuilding:HasGuns()) then
					
						-- Check for upgraded posts and armed buildings
						local iThreat = 0
						if (oBuilding:IsListeningPost()) then
							iThreat = iPostThreat
						else
							local sBuildingName	= oBuilding:GetBaseName()
							local sBuildingType, iBuildingThreat = cpu_manager.m_oRaceLoader:GetBuildingType(sRace, sBuildingName)
							iThreat = iBuildingThreat
						end
						
						-- Check if threat is in range of one of our units
						if (iThreat > 0) then
									
							-- Get turret position
							local vTurretPosition = oBuilding:GetPosition()
											
							-- Add the strenth of enemy turrets to total defend strength if they are close to one of our attack units
							local iSquadCount = table.getn( aUnits )
							for iLoop1 = iSquadCount, 1, -1 do
							
								-- Check distance
								if (distance_sqr(aUnits[iLoop1][1], vTurretPosition) < iRange) then
									
									-- Add turret strength to total defend strength
									iTotalDefendStrength = iTotalDefendStrength + iThreat
									
									-- Substract turret strength from squad defend strength capacity
									aUnits[iLoop1][2] = aUnits[iLoop1][2] - iThreat
									
									-- Check if squad defend strength exceeds limit
									if (aUnits[iLoop1][2] < 0) then
										table.remove(aUnits, iLoop1)
									end
									break
								end
							end
						end
					end
				end
			end
		end
	end

    aitrace("AttackStrategy: Attack Army Strength = "..tostring(iMyArmyStrength))
    aitrace("AttackStrategy: Target Enemy Strength = "..tostring(iEnemyArmyStrength))
    aitrace("AttackStrategy: Total Defend Strength = "..tostring(iTotalDefendStrength))

    -- Compare total defend strength with attack strength
    fRatio = cpu_manager:GetAttackRatio()
	if (iMyArmyStrength < fRatio * iTotalDefendStrength) then
		return false
	end
	return true
end

function AttackStrategy:CheckSuccess()

	aitrace("AttackStrategy: Check Success...")

	-- Check threat
	if (cpu_manager.terrain_analyzer:HasThreat(self.m_vAttackPosition, AttackStrategy.iLocalRange)) then
		return false
	end
	
	-- Check enemy buildings
	if (cpu_manager.cpu_player:FindFirstBaseEnemy(self.m_vAttackPosition, AttackStrategy.iLocalRange, 1) ~= nil) then
		return false
	end
	
	-- Check for strats to disown
	local oStrategicPoint = resource_manager:FindFirstStrategicPoint(self.m_vAttackPosition, AttackStrategy.iLocalRange)
	if (oStrategicPoint ~= nil) then
	
		-- Check owner
		local iOwnerID = oStrategicPoint:Owner()
		if (iOwnerID ~= 0 and not cpu_manager:IsFriendly(iOwnerID)) then
			return false
		end
	end
	
	-- Attack was successfull! Now try to initiate an attack chain.
	local iClosestDistance = 100
	local vNewAttackPosition = nil
	for oBuilding in self.m_oEnemy:GetBases() do
	
		-- Check for valid building
		if (oBuilding:IsValid()) then
					
			-- Check distance for attack chain
			local vPosition = oBuilding:GetPosition()
			local iDistance = cpu_manager:GetShortestPathingDistance(self.m_vAttackPosition, vPosition)
			if (iDistance < iClosestDistance) then
				iClosestDistance = iDistance
				vNewAttackPosition = vPosition
			end
		end
	end
	
	-- Check if we found a new attack position
	if (vNewAttackPosition ~= nil) then
		
		-- Check threat at position
		local iEnemyStrength, iAlliedStrength = cpu_manager:GetArmyStrengthAtPos(vNewAttackPosition, 50, true)
		local iMyArmyStrength = self.m_oAttackPlan:GetArmyStrength()
		if (3 * iEnemyStrength < 2 * (iAlliedStrength + iMyArmyStrength)) then
			
			-- Initiate attack chain
			aitrace("AttackStrategy: Attack successfull!!! Switch target...")
			self.m_vAttackPosition = vNewAttackPosition
			self.m_oAttackPlan.attack_pos = vNewAttackPosition
			return false
		end
	end
	
	-- Attack was successfull
	return true
end

function AttackStrategy:HelpAllyInNeed()

	aitrace("AttackStrategy: Check for allies in need...")

	-- Don't check if we're already supporting an ally
	if (self.m_bHelpFriend) then
		return
	end

	-- Get army strengths
	local iMyArmyStrength = cpu_manager:GetArmyStrength()
	local iEnemyArmyStrength = cpu_manager:GetArmyStrength(self.m_oEnemy)
	
	-- Get race specific support factor
	local fSupportFactor = cpu_manager:GetSupportAllyFactor()
	
	-- Get allied start positions
	local aAlliedStartPositions = {}
	for oPlayer in cpu_manager.stats:GetPlayerStats() do
	
		-- Check player status
		if (not oPlayer:IsPlayerDead() and not cpu_manager.player_stats:IsEnemy(oPlayer) and
			oPlayer:GetPlayerID() ~= cpu_manager.player_id) then
			
			-- Add start position
			table.insert(aAlliedStartPositions, oPlayer:GetStartingPosition())
		end		
	end
	
	-- Check if adjacent ally is in urgent need
	local vSupportPosition = nil
	local iCriticalRange = cpu_manager:GetCriticalRange()
	local iMinThreat = cpu_manager:GetTierLevel() * 400
	for oPlayer in cpu_manager.stats:GetPlayerStats() do
	
		-- Check player status
		if (not oPlayer:IsPlayerDead() and not cpu_manager.player_stats:IsEnemy(oPlayer) and
			oPlayer:GetPlayerID() ~= cpu_manager.player_id) then
			
			-- Check distance
			local vStartPosition = oPlayer:GetStartingPosition()
			local iDistance = cpu_manager:GetShortestPathingDistance(cpu_manager.start_pos, vStartPosition)
			local bClosestAlly = true
			for iLoop1 in aAlliedStartPositions do
			
				-- Check allied distance
				if (distance_sqr(aAlliedStartPositions[iLoop1], vStartPosition) > 1 and
					cpu_manager:GetShortestPathingDistance(aAlliedStartPositions[iLoop1], vStartPosition) < iDistance) then
					bClosestAlly = false
				end
			end
			
			-- Check only if we are the closest ally
			if (bClosestAlly and cpu_manager.terrain_analyzer:HasThreat(vStartPosition, iCriticalRange)) then

				-- Check situation
				if (self.m_oAttackPlan ~= nil) then
					local iAttackArmyStrength, vAttackArmyPos = self.m_oAttackPlan:GetArmyStrength()
					iDistance = math.min(iDistance, distance(vAttackArmyPos, vStartPosition))
				end
				local iAlliedArmyStrength = cpu_manager:GetArmyStrength(oPlayer)
				local iEnemyStrength, iAlliedStrength = cpu_manager:GetArmyStrengthAtPos(vStartPosition, iCriticalRange)
				local fModifier = math.max(1, iDistance / 100) / fSupportFactor
				if (iEnemyStrength > iMinThreat and iDistance < 450 and fModifier * iAlliedStrength < iEnemyStrength) then
				
					-- Help ally if the enemy we're attacking is not very weak compared to me
					if (fModifier * iMyArmyStrength < 4 * iEnemyArmyStrength) then
					
						-- Check if we should abort our attack
						if (iMyArmyStrength < 5000) then
							vSupportPosition = self:GetBestSupportPosition(vStartPosition, iCriticalRange + 50)
							break
						else
						
							-- Check if we should split our forces
							local iAttackStrength = self.m_oAttackPlan:GetArmyStrength()
							if (iAttackStrength > iMyArmyStrength / 2 + 500) then
								self.m_oAttackPlan:SplitArmy()
							end
							break
						end
					end
				end
			end
		end
	end
	
	-- Leave if we are not going to support an ally
	if (vSupportPosition == nil) then
		return
	end
	
	-- Reset attack
	self:ResetAttack()
	
	-- Create a new attack plan to assist ally
	iRequiredPower = math.max(cpu_manager:GetArmyStrength() * 2 / 3, 400)
	self.m_vAttackPosition = Vector3f(vSupportPosition)
	self.m_oEnemy = cpu_manager:FindCommonEnemyPlayer()
	self.m_bHelpFriend = true
	
	-- Set minimum amount of units
	local iMinArmyPower = math.max(self.info.MinArmyStrength, cpu_manager:GetTierLevel() * cpu_manager:MinArmyStrengthPerTier())
	iMinArmyPower = math.max(iMinArmyPower, iRequiredPower)

	-- Add attack plan
	aitrace("Abort attack and try to save my ally!!!")
	self.m_oAttackPlan = AttackPlan(self.m_oEnemy, self.m_vAttackPosition, cpu_manager.start_pos, iMinArmyPower, self.info.max_army_percentage)
	self:AddPlan(self.m_oAttackPlan)
end

function AttackStrategy:ChooseTarget()

	aitrace("AttackStrategy: Choose new target...")
	
	-- Reset attack
	self:ResetAttack()
	
    -- Don't choose new target if there's a big threat at the HQ
    if (cpu_manager:GetCriticalSituation() > 0) then
    	aitrace("AttackStrategy: Too dangerous to attack...")
    	return
    end
    
	-- Get info about all units available for attack
	local iMyArmyStrength = 0
	local iSquadCount = 0
	local bBaseBuster = false
	for oSquad in military_manager:GetUnlockedSquads() do
	   
		-- Check if squad is valid
		if (oSquad:IsValid()) then

			-- Check if squad is able to attack
			local oTactic = oSquad:GetTactic()
			if (not oSquad:IsEngineer() and oTactic:IsAttacker()) then
			
				-- Add squad strength to army strength
				iMyArmyStrength = iMyArmyStrength + oSquad:GetTactic():GetUnitStrength()
				iSquadCount = iSquadCount + 1
				
				-- Check for a commander or vehicle
				local oStats = oSquad:GetStats()
				if (oStats ~= nil) then
					
					-- Check armour class
					local eClass = oStats:GetClass()
					if (eClass == UnitStatsAI.UC_VehicleLow or eClass == UnitStatsAI.UC_VehicleMed or
						eClass == UnitStatsAI.UC_VehicleHigh or eClass == UnitStatsAI.UC_Commander) then
						bBaseBuster = true
					end
				end
			end
		end
	end
	
	-- Don't attack if I don't have enough units available
	local iMinArmyPower = math.max(self.info.MinArmyStrength, cpu_manager:GetTierLevel() * cpu_manager:MinArmyStrengthPerTier())
	if (iMyArmyStrength < iMinArmyPower or iSquadCount < 2 or not bBaseBuster) then
		return
	end

	-- Analyse the battle field
	self:AnalyseBattleField()
	
	--	Trace info (Only for debug purposes)
	--	for iLoop1 in self.m_aAllies do
	--		self.m_aAllies[iLoop1]:TraceInfo()
	--	end
	--	for iLoop1 in self.m_aEnemies do
	--		self.m_aEnemies[iLoop1]:TraceInfo()
	--	end
	
	-- Get info about myself
	local vMyArmyPosition	= self.m_aAllies[self.m_iMyself].vArmyPosition
	local vMyBasePosition	= self.m_aAllies[self.m_iMyself].Base.vPosition
	local sMyRace			= self.m_aAllies[self.m_iMyself].sRace
	local fMinEnemyBaseDist = 0
	
	-- Set force attack factor
	local iForceAttackStrength = cpu_manager:GetTierLevel() * cpu_manager:MinArmyStrengthPerTier() * 2
	
	-- Get closest enemy post
	local iClosestEnemyDistance = 10000
	for oStrategicPoint in resource_manager:GetStrategicPointAIs() do
	
		-- Check owner
		if (oStrategicPoint:HasListeningPost() and not cpu_manager:IsFriendly(oStrategicPoint:Owner())) then
			
			-- Check distance
			local iDistance = cpu_manager:GetShortestPathingDistance(cpu_manager.start_pos, oStrategicPoint:GetPosition())
			if (iDistance < iClosestEnemyDistance) then
				iClosestEnemyDistance = iDistance
			end
		end
	end
	iThreatRange = sqr(2 / 3 * iClosestEnemyDistance)
	
	-- Compare army strength with closest enemy army
	local iEnemyArmyStrength = 0
	local iClosestDistance = 0
	for iLoop1 in self.m_aEnemies do
	
		-- Check if enemy is alive
		if (not self.m_aEnemies[iLoop1].bDead) then
			
			-- Check distance
			local iDistanceToMyBase = distance_sqr(self.m_aEnemies[iLoop1].vArmyPosition, vMyBasePosition)
			if (iClosestDistance == 0 or iClosestDistance > iDistanceToMyBase) then
				iEnemyArmyStrength = self.m_aEnemies[iLoop1].iTotalArmyStrength
				
				-- Half enemy army strength if it's very far away
				local iDistanceToEnemyBase = distance_sqr(self.m_aEnemies[iLoop1].vArmyPosition, self.m_aEnemies[iLoop1].Base.vPosition)
				if (iDistanceToMyBase > iThreatRange and iDistanceToEnemyBase > iThreatRange) then
					iEnemyArmyStrength = iEnemyArmyStrength / 2
				end
			end
		end
	end
	local fRatio = cpu_manager:GetAttackRatio()
    if (iMyArmyStrength < fRatio * iEnemyArmyStrength and iMyArmyStrength < 2500) then
    	return
    end
	
	-- ****** Check for an enemy base I can handle *****
	local tBestBase =
	{
		iEnemy = 0,
		iPoints = 0,
		vPosition = Vector3f(0, 0, 0),
		iNeedPower = 0
	}
	for iLoop1 in self.m_aEnemies do
	
		-- Check if I can handle enemy
		if (not self.m_aEnemies[iLoop1].bDead and 4 * iMyArmyStrength > 3 * self.m_aEnemies[iLoop1].iTotalArmyStrength) then
	
			-- Value points
			local iPoints = 0
		
			-- Get the maximum enemy threat on the path to the target base
			local vBasePosition = self.m_aEnemies[iLoop1].Base.vPosition
			local iEnemyPower = self.m_aEnemies[iLoop1].Base.iAlliedLocalPower + self.m_aEnemies[iLoop1].Base.iAlliedNearPower / 2
			iEnemyPower = self:GetMaxThreatOnPath(vMyArmyPosition, vBasePosition, iEnemyPower)
			
			-- Get the allied power at the target base
			local iAlliedPower = self.m_aEnemies[iLoop1].Base.iEnemyLocalPower + self.m_aEnemies[iLoop1].Base.iEnemyNearPower / 2
			
			-- Calculate the potential power ratio of total allied to enemy forces at the enemy base (Max 40 points)
			iPoints = self:Evaluate(iAlliedPower + iMyArmyStrength, AttackStrategy.fBestAttackRatio * iEnemyPower, AttackStrategy.fWorstAttackRatio * iEnemyPower, 40)
			
			-- Calculate the distance of my army to the enemy base (Max 30 points)
			local iArmyToBaseDistance = distance(vMyArmyPosition, vBasePosition)
			iPoints = iPoints + self:Evaluate(iArmyToBaseDistance, AttackStrategy.iLocalRange, AttackStrategy.iMidRange, 30)
			
			-- Calculate the distance of my base to the enemy base (Max 30 points)
			local iBaseToBaseDistance = cpu_manager:GetShortestPathingDistance(vMyBasePosition, vBasePosition)
			iPoints = iPoints + self:Evaluate(iBaseToBaseDistance, AttackStrategy.iNearRange, AttackStrategy.iMidRange, 30)
			
			-- Set minimum enemy base distance
			if (fMinEnemyBaseDist == 0 or fMinEnemyBaseDist < iBaseToBaseDistance) then
				fMinEnemyBaseDist = iBaseToBaseDistance
			end
			
			-- Calculate the army strength I need
			local iRequiredStrength = math.min(AttackStrategy.fRequiredAttackRatio * iEnemyPower - iAlliedPower, AttackStrategy.iMaxArmySize - iAlliedPower)
			
			-- Check if this base is better than the previous base
			if (tBestBase.iPoints < iPoints and
				iAlliedPower < AttackStrategy.iMaxArmySize and
				not self.m_aEnemies[iLoop1].bDead and
				2 * iBaseToBaseDistance < 3 * iClosestEnemyDistance and
				(iRequiredStrength <= iMyArmyStrength or iMyArmyStrength >= iForceAttackStrength)) then
				
				-- Set new target base
				tBestBase.iPoints = iPoints
				tBestBase.iEnemy = iLoop1
				tBestBase.vPosition = vBasePosition
				tBestBase.iNeedPower = iRequiredStrength
			end
		end
	end
	
	-- ***** Check for an enemy listening post I can handle *****
	local tBestListeningPost =
	{
		iEnemy = 0,
		iPostID = 0,
		iPoints = 0,
		vPosition = Vector3f(0, 0, 0),
		iNeedPower = 0
	}
	for iLoop1 in self.m_aEnemies do
	
		for iLoop2 in self.m_aEnemies[iLoop1].ListeningPosts.vPosition do
		
			-- Check if player is dead or too strong
			if (self.m_aEnemies[iLoop1].bDead or 4 * iMyArmyStrength < 3 * self.m_aEnemies[iLoop1].iTotalArmyStrength) then
				break
			end
		
			-- Value points
			local iPoints = 0
			
			-- Get post strength
			local iPostStrength = cpu_manager:GetTurretPower(self.m_aEnemies[iLoop1].oPlayer:GetPlayerRaceName())
	
			-- Get the maximum enemy threat on the path to the target LP
			local vPostPosition = self.m_aEnemies[iLoop1].ListeningPosts.vPosition[iLoop2]
			local iEnemyPower = self.m_aEnemies[iLoop1].ListeningPosts.iAlliedLocalPower[iLoop2] + self.m_aEnemies[iLoop1].ListeningPosts.iAlliedNearPower[iLoop2] / 2
			if (self.m_aEnemies[iLoop1].ListeningPosts.bFortified[iLoop2]) then
				iEnemyPower = iEnemyPower + iPostStrength
			end
			local iEnemyPower = self:GetMaxThreatOnPath(vMyArmyPosition, vPostPosition, iEnemyPower)
			
			-- Get the allied power at the target LP plus the power of my army
			local iAlliedPower = self.m_aEnemies[iLoop1].ListeningPosts.iEnemyLocalPower[iLoop2] + self.m_aEnemies[iLoop1].ListeningPosts.iEnemyNearPower[iLoop2] / 2
			
			-- Calculate the potential power ratio of total allied to enemy forces at the enemy LP (Max 40 points)
			iPoints = self:Evaluate(iAlliedPower + iMyArmyStrength, AttackStrategy.fBestAttackRatio * iEnemyPower, AttackStrategy.fWorstAttackRatio * iEnemyPower, 40)
				
			-- Calculate the distance of my army to the enemy LP (Max 25 points)
			local iArmyToPostDistance = distance(vMyArmyPosition, vPostPosition)
			iPoints = iPoints + self:Evaluate(iArmyToPostDistance, AttackStrategy.iLocalRange, AttackStrategy.iMidRange, 25)
				
			-- Calculate the distance of my base to the enemy LP (Max 25 points)
			local iBaseToPostDistance = cpu_manager:GetShortestPathingDistance(vMyBasePosition, vPostPosition)
			iPoints = iPoints + self:Evaluate(iBaseToPostDistance, AttackStrategy.iNearRange, AttackStrategy.iMidRange, 25)
			
			-- Calculate the distance of the enemy base to the enemy LP (Max 10 points)
			local vEnemyBasePosition = self.m_aEnemies[iLoop1].Base.vPosition
			local iEnemyBaseToPostDistance = cpu_manager:GetShortestPathingDistance(vEnemyBasePosition, vPostPosition)
			iPoints = iPoints + self:Evaluate(iEnemyBaseToPostDistance, AttackStrategy.iNearRange, AttackStrategy.iMidRange, 10)
			
			-- Calculate the army strength I need
			local iRequiredStrength = math.min(AttackStrategy.fRequiredAttackRatio * iEnemyPower - iAlliedPower, AttackStrategy.iMaxArmySize - iAlliedPower)
			
			-- Check if this listening post is better than the previous listening post
			if (tBestListeningPost.iPoints < iPoints and
				iAlliedPower < AttackStrategy.iMaxArmySize and
				2 * iBaseToPostDistance < 3 * iClosestEnemyDistance and
				(iRequiredStrength <= iMyArmyStrength or iMyArmyStrength >= iForceAttackStrength)) then
				
				-- Set new target post
				tBestListeningPost.iPoints = iPoints
				tBestListeningPost.iEnemy = iLoop1
				tBestListeningPost.iPostID = iLoop2
				tBestListeningPost.vPosition = vPostPosition
				tBestListeningPost.iNeedPower = iRequiredStrength
			end
		end
	end	
	
	-- Check if an allied base needs help
	local tSupportBase =
	{
		iAlly = 0,
		iPoints = 0,
		vPosition = Vector3f(0, 0, 0),
		iNeedPower = 0
	}
	for iLoop1 in self.m_aAllies do
	
		-- Check if I can handle enemy
		if (not self.m_aAllies[iLoop1].bDead and self.m_aAllies[iLoop1].oPlayer:GetPlayerID() ~= cpu_manager.player_id) then
		
			-- Value points
			local iPoints = 0
		
			-- Get the enemy power at the allied base
			local iEnemyPower = self.m_aAllies[iLoop1].Base.iEnemyLocalPower + self.m_aAllies[iLoop1].Base.iEnemyNearPower / 2
		
			-- Get the allied power at the allied base
			local iAlliedPower = self.m_aAllies[iLoop1].Base.iAlliedLocalPower + self.m_aAllies[iLoop1].Base.iAlliedNearPower / 2
			
			-- Calculate the potential power ratio of allied to enemy forces at the allied base (Max 40 points)
			iPoints = self:Evaluate(iEnemyPower, AttackStrategy.fBestAttackRatio * iAlliedPower, iAlliedPower, 40) 	
			
			-- Continue only if help is needed
			if (iPoints > 0 and self.m_aAllies[iLoop1].oPlayer:GetPlayerID() ~= cpu_manager.player_id) then
			
				-- Calculate the distance of my army to the allied base (Max 25 points)
				local vBasePosition = self.m_aAllies[iLoop1].Base.vPosition
				local iArmyToBaseDistance = distance(vMyArmyPosition, vBasePosition)
				iPoints = iPoints + self:Evaluate(iArmyToBaseDistance, AttackStrategy.iLocalRange, AttackStrategy.iMidRange, 25)
				
				-- Calculate the distance of my base to the allied base (Max 35 points)
				local iBaseToBaseDistance = cpu_manager:GetShortestPathingDistance(vMyBasePosition, vBasePosition)
				iPoints = iPoints + self:Evaluate(iBaseToBaseDistance, AttackStrategy.iNearRange, AttackStrategy.iMidRange, 35)
				
				-- Calculate the army strength I need
				local iRequiredStrength = math.min(AttackStrategy.fRequiredAttackRatio * iEnemyPower - iAlliedPower, AttackStrategy.iMaxArmySize - iAlliedPower)
			
				-- Check if this base is in higher need than the previous base
				if (tSupportBase.iPoints < iPoints and
					iAlliedPower < AttackStrategy.iMaxArmySize and
					not self.m_aAllies[iLoop1].bDead and
					2 * iBaseToBaseDistance < 3 * iClosestEnemyDistance and
					(iRequiredStrength <= iMyArmyStrength or iMyArmyStrength >= iForceAttackStrength)) then
					
					-- Set new support base target
					tSupportBase.iPoints = iPoints
					tSupportBase.iAlly = iLoop1
					tSupportBase.vPosition = vBasePosition
					tSupportBase.iNeedPower = iRequiredStrength
				end
			end
		end
	end
	
	-- Check if an allied listening post needs help
	local tSupportListeningPost =
	{
		iAlly = 0,
		iPostID = 0,
		iPoints = 0,
		vPosition = Vector3f(0, 0, 0),
		iNeedPower = 0
	}
	for iLoop1 in self.m_aAllies do
	
		for iLoop2 in self.m_aAllies[iLoop1].ListeningPosts.vPosition do
		
			-- Check if player is dead
			if (self.m_aAllies[iLoop1].bDead or self.m_aAllies[iLoop1].oPlayer:GetPlayerID() == cpu_manager.player_id) then
				break
			end
		
			-- Value points
			local iPoints = 0
			
			-- Get post strength
			local iPostStrength = cpu_manager:GetTurretPower(self.m_aAllies[iLoop1].oPlayer:GetPlayerRaceName())
		
			-- Get the enemy power at the allied LP
			local iEnemyPower = self.m_aAllies[iLoop1].ListeningPosts.iEnemyLocalPower[iLoop2] + self.m_aAllies[iLoop1].ListeningPosts.iEnemyNearPower[iLoop2] / 2
		
			-- Get the allied power at the allied LP
			local iAlliedPower = self.m_aAllies[iLoop1].ListeningPosts.iAlliedLocalPower[iLoop2] + self.m_aAllies[iLoop1].ListeningPosts.iAlliedNearPower[iLoop2] / 2
			if (self.m_aAllies[iLoop1].ListeningPosts.bFortified[iLoop2]) then
				iAlliedPower = iAlliedPower + iPostStrength
			end
			
			-- Calculate the potential power ratio of allied to enemy forces at the allied post (Max 40 points)
			iPoints = self:Evaluate(iEnemyPower, AttackStrategy.fBestAttackRatio * iAlliedPower, iAlliedPower, 40) 	
			
			-- Continue only if help is needed any my army isn't much stronger
			if (iPoints > 0 and 3 * iEnemyPower > iMyArmyStrength) then
			
				-- Calculate the distance of my army to the allied post (Max 25 points)
				local vPostPosition = self.m_aAllies[iLoop1].ListeningPosts.vPosition[iLoop2]
				local iArmyToPostDistance = distance(vMyArmyPosition, vPostPosition)
				iPoints = iPoints + self:Evaluate(iArmyToPostDistance, AttackStrategy.iLocalRange, AttackStrategy.iMidRange, 25)
				
				-- Calculate the distance of my base to the allied post (Max 35 points)
				local iBaseToPostDistance = cpu_manager:GetShortestPathingDistance(vMyBasePosition, vPostPosition)
				iPoints = iPoints + self:Evaluate(iBaseToPostDistance, AttackStrategy.iNearRange, AttackStrategy.iMidRange, 35)
				
				-- Calculate the army strength I need
				local iRequiredStrength = math.min(AttackStrategy.fRequiredAttackRatio * iEnemyPower - iAlliedPower, AttackStrategy.iMaxArmySize - iAlliedPower)
			
				-- Check if this listening post is better than the previous listening post
				if (tSupportListeningPost.iPoints < iPoints and
					iAlliedPower < AttackStrategy.iMaxArmySize and
					2 * iBaseToPostDistance < 3 * iClosestEnemyDistance and
					(iRequiredStrength <= iMyArmyStrength or iMyArmyStrength >= iForceAttackStrength)) then
					
					-- Set new post support target
					tSupportListeningPost.iPoints = iPoints
					tSupportListeningPost.iAlly = iLoop1
					tSupportListeningPost.iPostID = iLoop2
					tSupportListeningPost.vPosition = vPostPosition
					tSupportListeningPost.iNeedPower = iRequiredStrength
				end
			end
		end
	end
	
	-- Modify result with racial behaviour
	local iModifier = cpu_manager:GetAttackModifier()
	if (iModifier < 0) then
	
		-- Bonus on support actions
		if (tSupportBase.iAlly > 0) then
			tSupportBase.iPoints = tSupportBase.iPoints - iModifier
		end
		if (tSupportListeningPost.iAlly > 0) then
			tSupportListeningPost.iPoints = tSupportListeningPost.iPoints - iModifier
		end		
	
	elseif (iModifier > 0) then
	
		-- Bonus on attack actions
		if (tBestBase.iEnemy > 0) then
			tBestBase.iPoints = tBestBase.iPoints + iModifier
		end
		if (tBestListeningPost.iEnemy > 0) then
			tBestListeningPost.iPoints = tBestListeningPost.iPoints + iModifier
		end
	end

	-- Check which military actions can be fullfilled, and then choose action
	local iRequiredPower = 0
	local iPoints = 0
	local sActionType = "Waiting..."
	
	-- Check for close enemy armies
	local iCriticalRange = cpu_manager:GetCriticalRange()
	local iMinThreat = cpu_manager:GetTierLevel() * 500
	for iLoop1 in self.m_aEnemies do
		
		-- Check if enemy is alive
		if (not self.m_aEnemies[iLoop1].bDead) then
			
			-- Check if enemy army is close to home base
			if (distance_sqr(vMyBasePosition, self.m_aEnemies[iLoop1].vArmyPosition) < iCriticalRange) then
				
				-- Check threat
				local iThreat, iSupport, iMySupport = cpu_manager:GetArmyStrengthAtPos(self.m_aEnemies[iLoop1].vArmyPosition, 50, true)
				local iSituation = iThreat - iSupport + iMySupport
				if (iThreat > iMinThreat) then
				
					-- Check if we're able to attack enemy force
					iPoints = 200
					if (iMyArmyStrength > iSituation) then
						iRequiredPower = iThreat
						self.m_vAttackPosition = Vector3f(self.m_aEnemies[iLoop1].vArmyPosition)
						sActionType = "Attack close enemy army"
						self.m_oEnemy = self.m_aEnemies[iLoop1].oPlayer
					end
					break
				end
			end
		end
	end
	
	-- Try to support allied base
	if (tSupportBase.iAlly > 0 and tSupportBase.iPoints > iPoints) then
	
		-- Set target
		iRequiredPower = tSupportBase.iNeedPower
		iPoints = tSupportBase.iPoints
		self.m_vAttackPosition = self:GetBestSupportPosition(tSupportBase.vPosition, AttackStrategy.iLocalRange)
		sActionType = "Support allied base "..tostring(self.m_aAllies[tSupportBase.iAlly].oPlayer:GetPlayerID())
		self.m_oEnemy = cpu_manager:FindCommonEnemyPlayer()
	end
	
	-- Try to attack enemy base
	if (tBestBase.iEnemy > 0 and tBestBase.iPoints > iPoints) then
	
		-- Set target (Attacking an enemy base gets a bonus of 10 points in tier 2+)
		iRequiredPower = tBestBase.iNeedPower
		iPoints = tBestBase.iPoints
		if (cpu_manager:GetTierLevel() > 1) then
			iPoints = iPoints + 10
		end
		self.m_vAttackPosition = Vector3f(tBestBase.vPosition)
		self.m_oEnemy = self.m_aEnemies[tBestBase.iEnemy].oPlayer
		sActionType = "Attack enemy base "..tostring(self.m_oEnemy:GetPlayerID())
	end
	
	-- Try to support an allied listening post
	if (tSupportListeningPost.iAlly > 0 and tSupportListeningPost.iPoints > iPoints) then
	
		-- Set target
		iRequiredPower = tSupportListeningPost.iNeedPower
		iPoints = tSupportListeningPost.iPoints
		self.m_vAttackPosition = self:GetBestSupportPosition(tSupportListeningPost.vPosition, AttackStrategy.iLocalRange)
		sActionType = "Support allied listening post "..tostring(self.m_aAllies[tSupportListeningPost.iAlly].oPlayer:GetPlayerID())
		self.m_oEnemy = cpu_manager:FindCommonEnemyPlayer()
	end

	-- Try to attack an enemy listening post
	if (tBestListeningPost.iEnemy > 0 and tBestListeningPost.iPoints > iPoints) then
	
		-- Set target
		iRequiredPower = tBestListeningPost.iNeedPower
		iPoints = tBestListeningPost.iPoints
		self.m_vAttackPosition = Vector3f(tBestListeningPost.vPosition)
		self.m_oEnemy = self.m_aEnemies[tBestListeningPost.iEnemy].oPlayer
		sActionType = "Attack enemy listening post of player "..tostring(self.m_oEnemy:GetPlayerID())
	end
	
	-- Create attack plan
	if (sActionType ~= "Waiting...") then
	
		-- Set minimum amount of units
		iRequiredPower = math.max(0, iRequiredPower)
		local iMinArmyPower = math.max(iMinArmyPower, iRequiredPower)

		-- Add attack plan
		self.m_oAttackPlan = AttackPlan(self.m_oEnemy, self.m_vAttackPosition, vMyArmyPosition, iMinArmyPower, self.info.max_army_percentage)
		self:AddPlan(self.m_oAttackPlan)
		
		-- Store time of next update
		self.m_iNextUpdate = g_iGMT + 10
	end

	-- Report action
	aitrace("AttackStrategy: -------------------- Conclusion --------------------")
	aitrace("Action: "..sActionType)
	aitrace("Value:	"..tostring(iPoints).." points")
	aitrace("Required power: "..tostring(iRequiredPower))
	aitrace("Attack position: "..tostring(self.m_vAttackPosition.x)..", "..tostring(self.m_vAttackPosition.z))
end

function AttackStrategy:GetMaxThreatOnPath(vMyArmyPos, vTargetPos, iTargetEnemyPower)

	-- Calculate distance from my army to the target
	local iDistanceToTarget = distance(vMyArmyPos, vTargetPos)
	local iMinDistance = (1 + AttackStrategy.fAttackDeviation) * iDistanceToTarget
	local iMaxDistance = (1 - AttackStrategy.fAttackDeviation) * iDistanceToTarget
	local iMaxEnemyPower = iTargetEnemyPower
	
	-- Check for all enemies, if they've a stronger post, base or army that blocks my target
	for iLoop1 in self.m_aEnemies do
	
		-- Check way distance through enemy army
		local iDistance1 = distance(vMyArmyPos, self.m_aEnemies[iLoop1].vArmyPosition)
		local iDistance2 = distance(self.m_aEnemies[iLoop1].vArmyPosition, vTargetPos)
		local iDistance = iDistance1 + iDistance2
		if (iDistance < iMaxDistance and iDistance > iMinDistance) then
		
			-- We now assume that we've to face at least a major part of the enemy army on our way to the target
			iMaxEnemyPower = math.max(iMaxEnemyPower, 2 / 3 * self.m_aEnemies[iLoop1].iTotalArmyStrength)
		end

		-- Check way distance through enemy base
		local iDistance1 = distance(vMyArmyPos, self.m_aEnemies[iLoop1].Base.vPosition)
		local iDistance2 = distance(self.m_aEnemies[iLoop1].Base.vPosition, vTargetPos)
		local iDistance = iDistance1 + iDistance2
		if (iDistance < iMaxDistance and iDistance > iMinDistance) then
		
			-- We now assume that we've to pass this base on our way to the target
			iMaxEnemyPower = math.max(iMaxEnemyPower, self.m_aEnemies[iLoop1].Base.iAlliedLocalPower)
		end
	
		-- Check way distance through enemy listening posts
		for iLoop2 in self.m_aEnemies[iLoop1].ListeningPosts.vPosition do
		
			iDistance1 = distance(vMyArmyPos, self.m_aEnemies[iLoop1].ListeningPosts.vPosition[iLoop2])
			iDistance2 = distance(self.m_aEnemies[iLoop1].ListeningPosts.vPosition[iLoop2], vTargetPos)
			iDistance = iDistance1 + iDistance2
			if (iDistance < iMaxDistance and iDistance > iMinDistance) then
		
				-- We now have to assume that we've to pass this post on our way to the target
				iMaxEnemyPower = math.max(iMaxEnemyPower, self.m_aEnemies[iLoop1].ListeningPosts.iAlliedLocalPower[iLoop2])
			end
		end
	end
	return iMaxEnemyPower
end

function AttackStrategy:Evaluate(iValue, iBestValue, iWorstValue, iMaxPoints)

	-- Check if high or low value is good
	if (iBestValue < iWorstValue) then
		
		-- Check best value
		if (iValue <= iBestValue) then
			return iMaxPoints
		end
		
		-- Check worst value
		if (iValue >= iWorstValue) then
			return 0
		end
		
		-- Calculate points
		return iMaxPoints - iMaxPoints / (iWorstValue - iBestValue) * (iValue - iBestValue)
	else
	
		-- Check best value
		if (iValue >= iBestValue) then
			return iMaxPoints
		end
		
		-- Check worst value
		if (iValue <= iWorstValue) then
			return 0
		end
		
		-- Calculate points
		return iMaxPoints / (iBestValue - iWorstValue) * (iValue - iWorstValue)
	end
end

function AttackStrategy:GetBestSupportPosition(vSupportPosition, iRange)

	-- Define squad filter functor
	local oSquadFilter = function( oSquadAI )
		return not oSquadAI:IsBroken()
	end
  
    -- Get closest enemy to support position
    local oEnemySquad = cpu_manager:FindClosestEnemy(vSupportPosition, iRange, oSquadFilter)
    if (oEnemySquad ~= nil) then
		return Vector3f(oEnemySquad:GetPosition())
	end
	
	-- If no valid enemy squad was found take support position
	return vSupportPosition
end

function AttackStrategy:SetVOFlag()

	AttackStrategy.bCounterVO = true
end

function AttackStrategy:Retreat(vRetreatPosition)

	-- Check if attack plan exist
	if (self.m_oAttackPlan ~= nil and not self.m_oAttackPlan:IsComplete()) then

		-- If no retreat position was given, then move to next friendly base
		if (vRetreatPosition == nil) then
		     
			local vBasePos = cpu_manager:FindClosestFriendlyBaseOrStrategicPoint(self.m_vAttackPosition, cpu_manager.start_pos, true, false)
			if (vBasePos ~= nil) then
				vRetreatPosition = Vector3f(vBasePos)
			end
		end
		   
		-- Retreat all units to retreat position
		if (vRetreatPosition ~= nil) then
		
			-- Retreat all attacking units
			self.m_oAttackPlan:Retreat(vRetreatPosition)
		end
	end
	
	-- Reset attack
	self:ResetAttack()
	
	-- Store time of next update
	self.m_iNextUpdate = g_iGMT + 30

	-- Pass control over to defend strategy
	self:PostEvent( Strategy.Events.OnFailure )
end

function AttackStrategy:AnalyseBattleField()

	aitrace("AttackStrategy: Analyse battle field...")

	-- Reset player-info arrays
	self.m_aAllies	= {}
	self.m_aEnemies	= {}
	
	-- Init ally and enemy sections
	local vMyBasePosition = Vector3f()
	for oPlayer in cpu_manager.stats:GetPlayerStats() do
	
		-- Check if player is still alive
		if (not oPlayer:IsPlayerDead()) then
	
			-- Create a baseinfo object
			local oPlayerInfo = PlayerInfo(oPlayer, AttackStrategy.iLocalRange, AttackStrategy.iNearRange, AttackStrategy.iMidRange, AttackStrategy.iLongRange)
			
			-- Add baseinfo object to ally or enemy section
			if (oPlayerInfo.bEnemy) then
				table.insert(self.m_aEnemies, oPlayerInfo)
			else
				table.insert(self.m_aAllies, oPlayerInfo)
			end
			
			-- Store main base position of current player
			if (oPlayer:GetPlayerID() == cpu_manager.player_id) then
				vMyBasePosition = oPlayerInfo.Base.vPosition
				self.m_iMyself = table.getn(self.m_aAllies)
			end
		end
	end
	local iAllyCount	= table.getn(self.m_aAllies)
	local iEnemyCount	= table.getn(self.m_aEnemies)
	
	-- Compute all allies
	for iLoop1 = 1, iAllyCount do
	
		-- Calculate distances of allied buildings to my position
		self.m_aAllies[iLoop1]:SetDistances(vMyBasePosition)
	
		-- Compute all allied squads
		for oSquad in self.m_aAllies[iLoop1].oPlayer:GetSquads() do

			if (oSquad:IsValid() and not oSquad:IsEngineer()) then
				
				-- Get squad position
				local vSquadPosition = oSquad:GetPosition()
				
				-- Get squad power
				local iSquadPower = cpu_manager:GetUnitStrength(oSquad)
				
				-- Add squad to army position
				self.m_aAllies[iLoop1]:AddSquadToArmyPos(iSquadPower, vSquadPosition)
				
				-- Only add squad info from allied players
				if (self.m_aAllies[iLoop1].oPlayer:GetPlayerID() ~= cpu_manager.player_id) then
								
					-- Add squad info to allied players information
					for iLoop2 = 1, iAllyCount do
						self.m_aAllies[iLoop2]:AddAlliedSquadInfo(iSquadPower, vSquadPosition)
					end
					
					-- Add squad info to enemy players information
					for iLoop2 = 1, iEnemyCount do
						self.m_aEnemies[iLoop2]:AddEnemySquadInfo(iSquadPower, vSquadPosition)
					end
				end
			end
		end
		
		-- Validate army position
		self.m_aAllies[iLoop1]:ValidateArmyPosition()
	end

	-- Compute all enemies
	for iLoop1 = 1, iEnemyCount do
	
		-- Calculate distances of enemy buildings to my position
		self.m_aEnemies[iLoop1]:SetDistances(vMyBasePosition)
	
		-- Compute all enemy squads
		for oSquad in self.m_aEnemies[iLoop1].oPlayer:GetSquads() do
								
			if (oSquad:IsValid() and not oSquad:IsEngineer()) then
				
				-- Get squad position
				local vSquadPosition = oSquad:GetPosition()
				
				-- Get squad power
				local iSquadPower = cpu_manager:GetUnitStrength(oSquad)
				
				-- Add squad to army position
				self.m_aEnemies[iLoop1]:AddSquadToArmyPos(iSquadPower, vSquadPosition)
								
				-- Add squad info to allied players information
				for iLoop2 = 1, iAllyCount do
					self.m_aAllies[iLoop2]:AddEnemySquadInfo(iSquadPower, vSquadPosition)
				end
				
				-- Add squad info to enemy players information
				for iLoop2 = 1, iEnemyCount do
					self.m_aEnemies[iLoop2]:AddAlliedSquadInfo(iSquadPower, vSquadPosition)
				end
			end
		end
		
		-- Validate army position
		self.m_aEnemies[iLoop1]:ValidateArmyPosition()
	end
end